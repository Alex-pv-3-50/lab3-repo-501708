# Лабораторная работа №4 - Хэш-функции


---

### Цель работы

Освоить принципы построения хэш-таблиц, научиться применять хэш-функции, методы разрешения коллизий и использовать тестирование для проверки корректности реализации.
Закрепить навыки работы с ранее реализованными структурами данных.

---

### Задание

1. Реализуйте **структуру данных "хэш-таблица"** на языке C.
   При этом:

   * необходимо использовать **реализованный ранее вектор (Vector)** из лабораторной работы №3;
   * допускается и рекомендуется **расширить вектор** дополнительными функциями для удобства работы (например, безопасное извлечение элемента, изменение размера и т.д.);
   * для хранения элементов можно использовать схему **открытой адресации** с **квадратичным пробированием**.

2. Реализуйте функции для работы с таблицей:

   * создание и освобождение (`createHashTable`, `freeHashTable`);
   * вставка элемента (`setItemHashTable`);
   * получение элемента по ключу (`getItemHashTable`);
   * удаление элемента (`popItemHashTable`);
   * перераспределение (rehash);
   * вычисление количества коллизий (`getCollisionCount`);
   * хэш-функции и функции сравнения можно взять из 3 лабораторной; 

3. Напишите **набор тестов** в отдельном файле **`tests.c`**, который проверяет:

   * корректность базовых операций;
   * поведение при коллизиях;
   * корректность при удалении и повторной вставке элементов;
   * угловые случаи и некорректные данные.

4. Измерить число коллизий для файлов `data/bad_cases.csv` и `data/good_cases.csv`. Измерения занести в [таблицу](https://docs.google.com/spreadsheets/d/1_X6Lqww1946Rd2Q58WNlL9eb0OEoVxO1lwLaApej-Uo/edit?usp=sharing).

   * Читаете файл и каждую строку записываете в хеш-таблицу (заготовка не даётся, пробуем делать сами. Всё по образу и подобию)
   * Для первого ключа (которого еще нет в хеш-таблице) устанавливаете значение 1
   * Для ключей которые уже есть в таблице - увеличиваете значение на 1
   * После того как весь файл прочитан и все ключи добавлены, capacity и кол-во коллизий заносите в таблицу напротив своей фамилии


---

### Требования к реализации

* Использовать ранее реализованную структуру `Vector` как основу для хранения пар ключ–значение.
* Не использовать глобальные переменные.
* Для разрешения коллизий применять **метод из таблицы ниже** .
* Реализовать возможность **rehash**, когда заполненность таблицы превышает 50%.
* Все выделенные ресурсы должны корректно освобождаться.
* Проверять корректность входных аргументов функций.
* При необходимости реализовать дополнительные методы у вектора.


#### Таблица вариантов пробирования
Порядок определения вариантов определяется вашим ментором! **УТОЧНИТЕ ЭТО!**
| №  | Метод разрешения коллизий                      | Хеш-функция                    |
|----|------------------------------------------------|--------------------------------|
| 1  | Цепочечный метод                               | Метод деления                  |
| 2  | Цепочечный метод                               | Метод умножения                |
| 3  | Свободная адресация (линейное исследование)    | Метод деления                  |
| 4  | Свободная адресация (линейное исследование)    | Метод умножения                |
| 5  | Свободная адресация (квадратичное исследование)| Метод деления                  |
| 6  | Свободная адресация (квадратичное исследование)| Метод умножения                |
| 7  | Свободная адресация (двойное хеширование)      | Метод деления                  |
| 8  | Свободная адресация (двойное хеширование)      | Метод умножения                |

---

### Требования к тестам

* Тесты располагаются в отдельном файле **`tests.c`**.

* Для проверки корректности используйте **assert** или собственные макросы проверки.

* Необходимо проверить:

  1. **Пустую таблицу** — поиск или удаление элемента в пустой таблице.
  2. **Минимальные данные** — вставка и получение одного элемента.
  3. **Коллизии** — несколько ключей с одинаковым хэшем.
  4. **Переполнение таблицы** — проверка корректной работы `rehash`.
  5. **Удаление и повторная вставка** — убедиться, что слот корректно освобождается.
  6. **Некорректные входные данные** — `NULL`-указатели, нулевые размеры и т.п.
  7. **Типичные сценарии** — вставка, поиск, удаление, повторная вставка.

---

### Пример corner case-тестов

| Сценарий                | Описание                                                                                                   |
| ----------------------- | ---------------------------------------------------------------------------------------------------------- |
| **Пустая таблица**      | Вызов `getItemHashTable` или `popItemHashTable` до вставки элементов должен возвращать `NULL`.             |
| **Один элемент**        | Проверить корректную вставку и извлечение одного ключа.                                                    |
| **Коллизии**            | Несколько ключей с одинаковым значением `hash(key) % capacity` должны корректно размещаться и извлекаться. |
| **Rehash**              | При заполненности > 50% должна произойти перераспределение элементов.                                      |
| **Удаление**            | После удаления элемент не должен находиться, но таблица должна продолжать работать.                        |
| **Некорректные данные** | Передача `NULL`-указателей в функции не должна приводить к падению программы.                              |


---

### Пример тестов

```c
void test_basic_insertion()
{
    printf("Test: basic insertion ... ");
    HashTable *table = createHashTable(sizeof(int), sizeof(int));

    int key = 10, val = 100;
    setItemHashTable(table, &key, &val, HashInt, CmpInt);

    int *res = getItemHashTable(table, &key, HashInt, CmpInt);
    assert(res && *res == 100);

    freeHashTable(table);
    printf("OK\n");
}
```

### Дополнительная задача

**!Только для тех кто выполнил базовую задачу и готов попробовать сделать нечто большее!**

#### Реализовать LRU-кеш, используя хеш-таблицу + двусвязный список. Двусвязный список здесь необходим для поддержания порядка использования. Чем чаще ключ запрашивается, тем он ближе к head.

* head → самый недавно использованный
* tail → самый давно использованный

*Для этого необходимо:*
1. Реализовать двусвязный список
2. Модифицировать хеш-таблицу (лучше в отдельном файле) для работы с двусвязным списком
3. Модифицировать функцию для получения значения. Если мы получаем значение по ключу, который является не `head` в списке, его необходимо сдвинуть на 1 ближе к `head` (заменить prev на next)
4. Скачать [файл](https://disk.yandex.ru/d/q-NrrEaD-eDt5Q) с ключами
5. Посчитать через хеш-таблицу все ключи в файле
6. Реализовать функцию получения значения по ключу с подсчетом поиска (псевдокод будет ниже)
7. Занести в [таблицу](https://docs.google.com/spreadsheets/d/1_X6Lqww1946Rd2Q58WNlL9eb0OEoVxO1lwLaApej-Uo/edit?usp=sharing) полученные данные экспериментов для 4-х ключей (указанных в таблице)

#### Описание датасета
[Ссылка на оригинальный датасет](https://www.kaggle.com/competitions/web-traffic-time-series-forecasting/data).  
[Ваш файл](https://disk.yandex.ru/d/q-NrrEaD-eDt5Q) это по сути `train` выборка преобразованная в последовательность по датам посещения веб-страниц.
Например `["https://en.wikipedia.org/wiki/!vote", "https://en.wikipedia.org/wiki/One_Direction"]`.
Было зафиксировано что человек зашел на первую страницу, после на вторую (данные посещений оставлены только для англоязычных файлов и только просмотр их с десктопа). Также в вашем файле нет дат, чтобы было проще парсить.

#### Псевокод для подсчета числа поисков

```c
size_t getValueWithNumberOfSearches(HashTable* table, void* key, HashFunc hash, CmpFunc cmp) {
   DoublyLinkedList* list = getLinkedList(table, key, hash);
   if (!list) return 0;  // Если нет двусвязного списка по ключу - значит в целом по ключу нет значений

   int number_of_searches = 1;  // По умолчанию 1 - нашли двусвязный список
   Node* next = list->head;
   while (!next || cmp(getKeyFromNode(next->key), key) != 0) {
      number_of_searches++;  // При каждом шаге в двусвязном списке увеличиваем шаг
      next = next->next;
   }
   return number_of_searches;
}
```
